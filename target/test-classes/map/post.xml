<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sqlMap
    PUBLIC "-//ibatis.apache.org//DTD SQL Map 2.0//EN"
    "http://ibatis.apache.org/dtd/sql-map-2.dtd">
<sqlMap namespace="PostMapper">

	<!-- 文章表SQL -->
	<!--2012-05-21-->
   	<typeAlias alias="Post" type="com.taobao.freeproj.domain.Post"/>
   	<typeAlias alias="PostEx" type="com.taobao.freeproj.domain.PostEx"/>
   	
   	<!-- 要使用到PostEx对象和@postId参数 2012.5.21 
	2012-05-26 【问题】：update时，如果只更新了一个字段，则历史表里也仅仅只记录了这一个字段的内容
	-->
   	<sql id="postExtra">
   		<!--插入与标签、类别的关联关系-->
		<dynamic>
			<isNotNull property="catalogIdList">
		    	<iterate property="catalogIdList" prepend="" conjunction="">
					insert ignore into r_post_cata_relation (postId,catalogId) values(@postId,#catalogIdList[]#);
				</iterate>
			</isNotNull>
 		</dynamic>
 		
 		<!--插入历史表
		如果内容没有改变，则不再插入历史表 2012-06-14 by liusan.dyf
		-->
		<dynamic>
			<isNotEqual prepend="" property="extra" compareValue="304">
				INSERT INTO r_post_history(`title`,`content`,`author`,`authorUrl`,`createDate`,`source`,`sourceUrl`,`summary`,`status`,`modifier`,`modifiedDate`,`revision`,`modificationComment`,`isPublic`,`postId`,`ip`,`catalogs`)
				VALUES
				(#title#, #content#, #author#, #authorUrl#, now(), #source#, #sourceUrl#, #summary#, #status#, #modifier#, now(),#revision#,#modificationComment#,#isPublic#,@postId,#ip#,#catalogs#);	
			</isNotEqual>
		</dynamic>
		
		<!--更新类目、标签关联的post数目
		2012-05-31取消，放到程序外面统一处理
		-->
		<!--
		<dynamic>
			<isNotNull property="catalogIdList">
		    	<iterate property="catalogIdList" prepend="" conjunction="">
					update common_catalog set reservedInt = 
					(select count(1) from r_post_cata_relation where catalogId = #catalogIdList[]# and postId = @postId) 
					where code=#catalogIdList[]#;
				</iterate>
			</isNotNull>
 		</dynamic>
		-->
   	</sql>
   
   <!-- 以statement/insert替换select，程序中使用sqlMapClient.insert()来执行语句，解决queryForXX无限循环的bug 2010-05-22 -->
  	<insert id="insert" parameterClass="PostEx">
		<!--插入主表-->
		INSERT INTO r_post
		(`title`,`content`,`author`,`authorUrl`,`createDate`,`source`,`sourceUrl`,`summary`,`status`,`modifier`,`modifiedDate`,`revision`,`modificationComment`,`isPublic`,`catalogs`)
		VALUES
		(#title#, #content#, #author#, #authorUrl#, now(), #source#, #sourceUrl#, #summary#, #status#, #modifier#, now(),#revision#,#modificationComment#,#isPublic#,#catalogs#);
		
		<!-- 将文章ID赋值，用于后面的关联关系 -->
		SET @postId = LAST_INSERT_ID();

		<include refid="postExtra"/>
		
		<selectKey keyProperty="id" type="post" resultClass="int">
      		select @postId as value
    	</selectKey>
		
	</insert>
	
	<!--
	2012-05-26 status的isNotEqual by liusan.dyf
	-->
	<insert id="update" parameterClass="PostEx">
		<!--更新主表-->
		update `r_post` set
		<dynamic>
			<isNotEmpty property="title">
				`title` = #title#,
			</isNotEmpty>
			<isNotEmpty property="content">
				`content` = #content#, 
			</isNotEmpty>
			<isNotEmpty property="source">
	        	`source` = #source#,
	        </isNotEmpty>
	        <isNotEmpty property="sourceUrl">
	        	`sourceUrl` = #sourceUrl#,
	        </isNotEmpty>
	        <isNotEmpty property="summary">
	        	`summary` = #summary#,
	        </isNotEmpty>
	        <isNotEmpty property="status">
				<isNotEqual prepend="" property="status" compareValue="0">
					`status` = #status#,
				</isNotEqual>
	        </isNotEmpty>
	        <isNotEmpty property="modifier">
	        	`modifier` = #modifier#,
	        </isNotEmpty>
			<isNotEmpty property="modificationComment">
				`modificationComment` = #modificationComment#,
			</isNotEmpty>
			
			<!--2012-06-04-->
			<isNotEmpty property="isPublic">
				<isNotEqual prepend="" property="isPublic" compareValue="0">
					`isPublic` = #isPublic#,
				</isNotEqual>
			</isNotEmpty>			
			
			<isNotEmpty property="catalogs">
	        	`catalogs` = #catalogs#,
	        </isNotEmpty>
			
			<!--2012-06-19 如果内容没有改变，则不用增加版本号-->
			<isNotEqual prepend="" property="extra" compareValue="304">
				`revision` = `revision` + 1,
			</isNotEqual>
		</dynamic>
				<!--`isPublic` = `isPublic` | #isPublic#,-->
				`modifiedDate` = now()
		where `id` = #id#;
				
		<!-- 将文章ID赋值，用于后面的关联关系 -->
		SET @postId = #id#;

		<include refid="postExtra"/>		
		
		<!--删除被删除的类目、标签
		如果不修改catalog，则该参数要设置为null 2012-06-13，否则，会清空原来设置的类目
		-->		
		<dynamic>
			<isNotNull property="catalogIdList">
				delete from r_post_cata_relation where postId=#id# and catalogId not in 
		    	<iterate property="catalogIdList" open="(" close=")" conjunction=",">   
					#catalogIdList[]#   
				</iterate> 
				;
			</isNotNull>
 		</dynamic>
	</insert>
	
	<select id="getById" resultClass="PostEx" parameterClass="int">
		SELECT * FROM `r_post` where id = #value# ;
	</select>
	
	<!-- 
	根据文章ID查询当前版本数，无需返回整个文章对象（因为文章内容有的很多）
	用于更新时检查版本是否是最新的，如果不是，则更新失败 
	-->
	<select id="getRevisionNumberById" resultClass="int" parameterClass="int">
		SELECT `revision` FROM `r_post` where id = #value# ;
	</select>
	
	<sql id="selectClause">
		FROM `r_post` a
		<dynamic>
			<isNotEmpty property="catalogId">
				INNER join r_post_cata_relation b
				on a.id = b.postId
			</isNotEmpty>
		</dynamic>
		where 1=1
		<dynamic>
			<isNotEmpty property="catalogId">
				and b.catalogId = #catalogId#
			</isNotEmpty>
			
			<isNotEmpty property="status">
				and a.`status` = #status#
			</isNotEmpty>
			
			<!--2012-05-25 by liusan.dyf-->
			<isNotEmpty property="isPublic">
				and a.`isPublic` = #isPublic#
			</isNotEmpty>
			
			<isNotEmpty property="modifier">
				and a.modifier = #modifier#
			</isNotEmpty>
			<isNotEmpty property="author">
				and a.`author` = #author#
			</isNotEmpty>
			<isNotEmpty property="startTime">
				and a.createDate &gt;= #startTime# 
			</isNotEmpty>
			<isNotEmpty property="endTime">
				and a.createDate &lt;= #endTime#
			</isNotEmpty>
			
			<!--2012-06-11 by liusan.dyf-->
			<isNotEmpty property="title">
				and a.title like  CONCAT('%',#title#,'%')
			</isNotEmpty>
			
		</dynamic>
	</sql>
	
	<!-- 根据文章所属类目（或标签）、作者和时间范围查询 
	2012-05-22 by liusan.dyf 修改select出的字段
	-->
	<select id="getPagedList" resultClass="PostEx" parameterClass="hashmap">
		SELECT a.`id`,
			  a.`title`,
			  <!--a.`content`,-->
			  a.`author`,
			  a.`authorUrl`,
			  a.`createDate`,
			  a.`source`,
			  a.`sourceUrl`,
			  a.`summary`,
			  a.`status`,
			  a.`modifier`,
			  a.`modifiedDate`,
			  a.`revision`,
			  a.`modificationComment`,
			  a.`isPublic`,
			  a.`catalogs`
		<include refid="selectClause"/>	
		order by a.id desc
		limit #skip#,#limit#;
	</select>
	
	<!-- 根据文章所属类目（或标签）、作者和时间范围查询 -->
	<select id="getCount" resultClass="int" parameterClass="hashmap">
		SELECT count(0) 
		<include refid="selectClause"/>	
		;
	</select>
	
	<!-- 根据文章编号获取历史信息 -->
	<select id="getPagedRevisionList" resultClass="PostEx" parameterClass="hashmap">
		SELECT `id`,
		  `title`,
		  `author`,
		  `authorUrl`,
		  `createDate`,
		  `source`,
		  `sourceUrl`,
		  `summary`,
		  `status`,
		  `modifier`,
		  `modifiedDate`,
		  `revision`,
		  `modificationComment`,
		  `isPublic`,
		  `catalogs`
		FROM `r_post_history` where `postId` = #postId#
		order by id desc
		limit #skip#,#limit#;
	</select>
	
	<!-- 历史版本数目 -->
	<select id="getRevisionsCount" resultClass="int" parameterClass="int">
		SELECT count(0) FROM `r_post_history` where `postId` = #value#
		;
	</select>
	
	<!-- 根据历史变更ID查询文章版本，版本对比时读取两次 -->
	<select id="getRevisionX" resultClass="PostEx" parameterClass="int">
		SELECT * FROM `r_post_history` where `id` = #value#;
	</select>
	
	<!-- 根据历史变更ID查询文章版本，版本对比时读取两次 -->
	<select id="getRevisionListX" resultClass="PostEx" parameterClass="hashmap">
		SELECT * FROM `r_post_history` where `id` in 
		<iterate property="idList" open="(" close=")" conjunction=",">   
				#idList[]#   
		</iterate>
		;
	</select>
	
	<!-- 根据历史变更ID查询文章版本，版本对比时读取两次 -->
	<select id="getRevision" resultClass="PostEx" parameterClass="hashmap">
		SELECT * FROM `r_post_history` where `postId` = #postId# and `revision`=#revision# limit 1;
	</select>
	
	<delete id="deleteById" parameterClass="int">
		DELETE FROM `r_post` WHERE id = #value#;
	</delete>
	
	<!--2012-05-31 by liusan.dyf 在sync和addToCatalog里使用
	末尾不要分号，后面可能还有条件 2012-06-13
	-->
	<sql id="syncClause">
		UPDATE 
		`r_post` a
		SET
		a.`catalogs` = 
		(
			SELECT GROUP_CONCAT(IFNULL(b.title,'no_name'), ':', r.catalogId) FROM r_post_cata_relation r
			LEFT JOIN common_catalog b
			ON r.catalogId = b.code
			WHERE r.postId = a.`id`
		)
	</sql>
	
	<!--2012-05-31 by liusan.dyf
	1，同步post表的catalogs冗余字段的值
	2，删除掉已经删除了的tag、类别
	TODO 同步数量
	-->
	<update id="sync">
		DELETE FROM r_post_cata_relation WHERE `catalogId` NOT IN(SELECT `code` FROM `common_catalog`);
	
		<include refid="syncClause"/>	
		;
	</update>
	
	<!--2012-05-31 by liusan.dyf 把一批post归类到某个类别
	确保idList不能为空列表
	-->
	<update id="addToCatalog" parameterClass="hashmap">
		<!--插入关联表-->
		<iterate property="idList" open="" close="" conjunction="">   
			insert ignore into r_post_cata_relation (postId,catalogId) values(#idList[]#,#catalogId#);
		</iterate>
		
		<!--更新冗余-->
		<include refid="syncClause"/>	
		where a.id in
		<iterate property="idList" open="(" close=")" conjunction=",">   
			#idList[]#   
		</iterate>
		;
	</update>
	
	<!--2012-05-31 by liusan.dyf 把一批post从某个类别里排除
	确保idList不能为空列表
	-->
	<update id="excludeCatalog" parameterClass="hashmap">
		<!--删除关联表-->
		<iterate property="idList" open="" close="" conjunction="">   
			delete from r_post_cata_relation where postId= #idList[]# and catalogId = #catalogId#;
		</iterate>
		
		<!--更新冗余-->
		<include refid="syncClause"/>	
		where a.id in
		<iterate property="idList" open="(" close=")" conjunction=",">   
			#idList[]#   
		</iterate>
		;
	</update>
	
	<!-- 2012-06-05 删除 -->
	<delete id="delete" parameterClass="hashmap">
		DELETE FROM `r_post` where `id` in 
		<iterate property="idList" open="(" close=")" conjunction=",">   
				#idList[]#   
		</iterate>
		;
		DELETE FROM `r_post_cata_relation` where `postId` in 
		<iterate property="idList" open="(" close=")" conjunction=",">   
				#idList[]#   
		</iterate>
		;
	</delete>
	
	<!-- 根据类目编号列表来拉取文章 2012-06-11
	参数里要包含catalogidList，类型List<long>；limit，类型int
	-->
	<select id="getTopByCatalogs" resultClass="PostEx" parameterClass="hashmap">
		SELECT title,id FROM r_post WHERE id IN 
			(
				SELECT postId FROM `r_post_cata_relation` WHERE catalogId IN 
				<iterate property="catalogIdList" open="(" close=")" conjunction=",">   
					#catalogIdList[]#   
				</iterate>
			)
		ORDER BY id DESC
		LIMIT $limit$;
	</select>
	
	<!--
	找出同时具有2个目录的post的编号列表 2012-06-14 by liusan.dyf
	参数为2个类目编号
	-->
	<select id="getIdList_IntersectCatalogs" resultClass="int" parameterClass="hashmap">
		SELECT a.postId FROM r_post_cata_relation a
		INNER JOIN r_post_cata_relation b
		USING (postId)
		WHERE a.catalogId = #a# AND b.catalogId = #b#;
	</select>
	
	<!--
	2012-06-15 by liusan.dyf
	业务方法，不通用，找到哪些条目（引用）被解读过
	引用的范围是777开头的9位数字
	解读编号为555569382
	-->
	<select id="getQuotedEntryIdList" resultClass="int">
		SELECT a.catalogId FROM r_post_cata_relation a
		INNER JOIN r_post_cata_relation b
		USING (postId)
		WHERE a.catalogId &gt; 777000000 AND a.catalogId &lt; 800000000 
		AND b.catalogId = 555569382;
	</select>
    	
</sqlMap>